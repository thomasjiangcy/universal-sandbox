export const TCP_PROXY_PORT = 9000;

const TCP_PROXY_SCRIPT = [
  "const http = require('http');",
  "const crypto = require('crypto');",
  "const net = require('net');",
  "const PORT = Number(process.env.US_BX_TCP_PROXY_PORT || '9000');",
  "const TARGET_PORT = process.env.US_BX_TCP_PROXY_TARGET_PORT ? Number(process.env.US_BX_TCP_PROXY_TARGET_PORT) : null;",
  "const INIT_TIMEOUT_MS = 5000;",
  "const MAX_INIT_BYTES = 4096;",
  "const server = http.createServer();",
  "const MAGIC = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';",
  "const sendFrame = (socket, opcode, payload) => {",
  "  const length = payload.length;",
  "  let header;",
  "  if (length < 126) {",
  "    header = Buffer.alloc(2);",
  "    header[1] = length;",
  "  } else if (length < 65536) {",
  "    header = Buffer.alloc(4);",
  "    header[1] = 126;",
  "    header.writeUInt16BE(length, 2);",
  "  } else {",
  "    header = Buffer.alloc(10);",
  "    header[1] = 127;",
  "    header.writeBigUInt64BE(BigInt(length), 2);",
  "  }",
  "  header[0] = 0x80 | (opcode & 0x0f);",
  "  socket.write(Buffer.concat([header, payload]));",
  "};",
  "const parseFrames = (buffer) => {",
  "  const frames = [];",
  "  let offset = 0;",
  "  while (offset + 2 <= buffer.length) {",
  "    const byte1 = buffer[offset];",
  "    const byte2 = buffer[offset + 1];",
  "    const fin = (byte1 & 0x80) !== 0;",
  "    const opcode = byte1 & 0x0f;",
  "    const masked = (byte2 & 0x80) !== 0;",
  "    let length = byte2 & 0x7f;",
  "    let headerSize = 2;",
  "    if (length === 126) {",
  "      if (offset + 4 > buffer.length) break;",
  "      length = buffer.readUInt16BE(offset + 2);",
  "      headerSize = 4;",
  "    } else if (length === 127) {",
  "      if (offset + 10 > buffer.length) break;",
  "      const value = buffer.readBigUInt64BE(offset + 2);",
  "      if (value > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error('Frame too large');",
  "      length = Number(value);",
  "      headerSize = 10;",
  "    }",
  "    const maskOffset = offset + headerSize;",
  "    const dataOffset = maskOffset + (masked ? 4 : 0);",
  "    const frameEnd = dataOffset + length;",
  "    if (frameEnd > buffer.length) break;",
  "    let payload = buffer.subarray(dataOffset, frameEnd);",
  "    if (masked) {",
  "      const mask = buffer.subarray(maskOffset, maskOffset + 4);",
  "      const unmasked = Buffer.alloc(payload.length);",
  "      for (let i = 0; i < payload.length; i += 1) {",
  "        unmasked[i] = payload[i] ^ mask[i % 4];",
  "      }",
  "      payload = unmasked;",
  "    }",
  "    frames.push({ fin, opcode, payload });",
  "    offset = frameEnd;",
  "  }",
  "  return { frames, remaining: buffer.subarray(offset) };",
  "};",
  "server.on('upgrade', (req, socket) => {",
  "  const key = req.headers['sec-websocket-key'];",
  "  if (typeof key !== 'string') {",
  "    socket.end('HTTP/1.1 400 Bad Request\\r\\n\\r\\n');",
  "    return;",
  "  }",
  "  const accept = crypto.createHash('sha1').update(key + MAGIC).digest('base64');",
  "  const response = [",
  "    'HTTP/1.1 101 Switching Protocols',",
  "    'Upgrade: websocket',",
  "    'Connection: Upgrade',",
  "    'Sec-WebSocket-Accept: ' + accept,",
  "    '\\r\\n',",
  "  ].join('\\r\\n');",
  "  socket.write(response);",
  "  socket.setNoDelay(true);",
  "  let buffer = Buffer.alloc(0);",
  "  let initialized = false;",
  "  let tcp = null;",
  "  const initTimer = setTimeout(() => {",
  "    socket.end();",
  "    if (tcp) tcp.destroy();",
  "  }, INIT_TIMEOUT_MS);",
  "  const close = () => {",
  "    clearTimeout(initTimer);",
  "    if (tcp) tcp.destroy();",
  "    socket.end();",
  "  };",
  "  socket.on('data', (chunk) => {",
  "    buffer = Buffer.concat([buffer, chunk]);",
  "    let parsed;",
  "    try {",
  "      parsed = parseFrames(buffer);",
  "    } catch {",
  "      close();",
  "      return;",
  "    }",
  "    buffer = parsed.remaining;",
  "    for (const frame of parsed.frames) {",
  "      if (!frame.fin) {",
  "        close();",
  "        return;",
  "      }",
  "      if (frame.opcode === 0x8) {",
  "        close();",
  "        return;",
  "      }",
  "      if (frame.opcode === 0x9) {",
  "        sendFrame(socket, 0xA, frame.payload);",
  "        continue;",
  "      }",
  "      if (!initialized) {",
  "        if (frame.opcode !== 0x1 || frame.payload.length > MAX_INIT_BYTES) {",
  "          close();",
  "          return;",
  "        }",
  "        let init;",
  "        try {",
  "          init = JSON.parse(frame.payload.toString('utf8'));",
  "        } catch {",
  "          close();",
  "          return;",
  "        }",
  "        const host = typeof init.host === 'string' ? init.host : 'localhost';",
  "        const port = init.port;",
  "        if (!Number.isInteger(port) || port < 1 || port > 65535) {",
  "          close();",
  "          return;",
  "        }",
  "        if (TARGET_PORT && port !== TARGET_PORT) {",
  "          close();",
  "          return;",
  "        }",
  "        if (host !== 'localhost' && host !== '127.0.0.1' && host !== '::1') {",
  "          close();",
  "          return;",
  "        }",
  "        tcp = net.createConnection({ host, port });",
  "        tcp.on('connect', () => {",
  "          initialized = true;",
  "          clearTimeout(initTimer);",
  "          sendFrame(socket, 0x1, Buffer.from(JSON.stringify({ status: 'connected', target: host + ':' + port })));",
  "        });",
  "        tcp.on('data', (data) => sendFrame(socket, 0x2, data));",
  "        tcp.on('error', close);",
  "        tcp.on('close', close);",
  "        continue;",
  "      }",
  "      if (frame.opcode === 0x2 && tcp) {",
  "        tcp.write(frame.payload);",
  "      }",
  "    }",
  "  });",
  "  socket.on('close', close);",
  "  socket.on('error', close);",
  "});",
  "server.listen(PORT, '0.0.0.0');",
].join("\n");

export const buildProxyPrepareScript = (): string => {
  const scriptPath = "/tmp/usbx-tcp-proxy.js";
  return [
    "if ! command -v node >/dev/null 2>&1; then",
    "  exit 3",
    "fi",
    `cat <<'US_BX_TCP_PROXY' > ${scriptPath}`,
    TCP_PROXY_SCRIPT,
    "US_BX_TCP_PROXY",
  ].join("\n");
};

export const buildPortCheckScript = (port: number, retries: number): string => `
check_port() {
  if command -v ss >/dev/null 2>&1; then
    ss -ltn "sport = :${port}" | awk 'NR>1 {found=1} END {exit found?0:1}'
    return $?
  fi
  if command -v lsof >/dev/null 2>&1; then
    lsof -nPiTCP:${port} -sTCP:LISTEN -t >/dev/null 2>&1
    return $?
  fi
  return 2
}

i=0
while [ $i -le ${retries} ]; do
  check_port
  rc=$?
  if [ $rc -eq 0 ]; then
    exit 0
  fi
  if [ $rc -eq 2 ]; then
    exit 2
  fi
  i=$((i+1))
  if [ $i -le ${retries} ]; then
    sleep 1
  fi
done
exit 1
`;
